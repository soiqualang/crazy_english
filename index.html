<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Học Tiếng Anh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        .card-stack {
            perspective: 1000px;
            position: relative;
            width: 90vw;
            height: 50vh;
            max-width: 400px;
            max-height: 250px;
        }
        .card {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: pointer;
            user-select: none;
            transition: transform 0.5s, opacity 0.5s;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border-radius: 1rem; /* rounded-2xl */
        }
        .card.is-flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            text-align: center;
            border-radius: 1rem; /* rounded-2xl */
        }
        .card-face--back {
            transform: rotateY(180deg);
        }
        .dragging {
            transition: none;
        }
        .swipe-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .swipe-indicator.know {
            color: #10B981; /* green-500 */
            border: 5px solid #10B981;
            transform: rotate(-20deg);
        }
        .swipe-indicator.unknown {
            color: #EF4444; /* red-500 */
            border: 5px solid #EF4444;
            transform: rotate(20deg);
            left: auto;
            right: 20px;
        }
        .hidden { display: none; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <h1 id="main-title" class="text-3xl font-bold text-center mb-2 text-gray-700">Flashcard Tiếng Anh</h1>
        <p class="text-center text-gray-500 mb-6">Quẹt phải nếu đã biết, quẹt trái nếu chưa biết.</p>

        <!-- Nút chọn chế độ -->
        <div id="deck-selection" class="flex justify-center flex-wrap gap-2 mb-6">
            <button id="btn-vocab" class="px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition-colors">
                4000 Từ vựng
            </button>
            <button id="btn-sentences" class="px-4 py-2 bg-gray-300 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75 transition-colors">
                400 Câu
            </button>
             <button id="btn-review" class="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75 transition-colors hidden" disabled>
                Ôn tập (0)
            </button>
        </div>
         <div id="review-controls" class="hidden justify-center mb-6">
            <button id="btn-back" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600">
                &larr; Quay lại
            </button>
        </div>


        <!-- Khu vực thẻ -->
        <div id="card-container" class="relative flex items-center justify-center mb-6">
             <div class="swipe-indicator know p-4 rounded-lg">Biết</div>
             <div class="swipe-indicator unknown p-4 rounded-lg">Chưa biết</div>
            <div id="card-stack" class="card-stack">
                <!-- Thẻ sẽ được thêm vào đây bằng JavaScript -->
                <div id="loading-indicator" class="w-full h-full flex items-center justify-center text-gray-500">
                    <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span>Đang tải dữ liệu...</span>
                </div>
            </div>
        </div>

        <!-- Thông tin tiến độ -->
        <div id="progress-info" class="text-center text-gray-600 mb-6 h-6"></div>

        <!-- Nút hành động -->
        <div class="flex justify-center items-center space-x-4">
            <button id="btn-unknown" class="w-20 h-20 bg-white rounded-full shadow-lg flex items-center justify-center text-red-500 hover:bg-red-50 transition-colors focus:outline-none focus:ring-2 focus:ring-red-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <button id="btn-info" class="w-16 h-16 bg-white rounded-full shadow-lg flex items-center justify-center text-blue-500 hover:bg-blue-50 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>
            <button id="btn-known" class="w-20 h-20 bg-white rounded-full shadow-lg flex items-center justify-center text-green-500 hover:bg-green-50 transition-colors focus:outline-none focus:ring-2 focus:ring-green-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const cardStack = document.getElementById('card-stack');
        const cardContainer = document.getElementById('card-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressInfo = document.getElementById('progress-info');
        const mainTitle = document.getElementById('main-title');
        
        const deckSelection = document.getElementById('deck-selection');
        const reviewControls = document.getElementById('review-controls');

        const btnVocab = document.getElementById('btn-vocab');
        const btnSentences = document.getElementById('btn-sentences');
        const btnReview = document.getElementById('btn-review');
        const btnBack = document.getElementById('btn-back');

        const btnUnknown = document.getElementById('btn-unknown');
        const btnKnown = document.getElementById('btn-known');
        const btnInfo = document.getElementById('btn-info');
        const knowIndicator = cardContainer.querySelector('.swipe-indicator.know');
        const unknownIndicator = cardContainer.querySelector('.swipe-indicator.unknown');

        // --- Data URLs ---
        const VOCAB_URL = 'crazy_english_services/data/4000_Core_English_Vocabulary_Words.json';
        const SENTENCES_URL = 'crazy_english_services/data/400_crazy_english_trans.json';

        // --- App State ---
        let fullDecks = { vocab: [], sentences: [] }; // Store the complete original decks
        let currentData = []; // The cards currently being displayed/learned
        
        // FIX: State object to hold all progress for each deck
        let deckStats = {
            vocab: { knownCount: 0, unknownCount: 0, seenWords: new Set() },
            sentences: { knownCount: 0, unknownCount: 0, seenWords: new Set() }
        };
        let reviewLists = { vocab: [], sentences: [] };

        let currentIndex = 0; // Index for the currentData array
        let reviewSessionStats = { knownCount: 0, unknownCount: 0 }; // Separate stats for review sessions
        
        let activeCard = null;
        let isDragging = false;
        let startX = 0, startY = 0;
        let currentX = 0, currentY = 0;
        let isReviewing = false;
        let activeDeckType = 'vocab';
        let deckBeingReviewed = '';

        // --- Data Fetching ---
        async function fetchData(url, type) {
            // Only fetch if the deck hasn't been loaded yet
            if (fullDecks[type] && fullDecks[type].length > 0) {
                return fullDecks[type];
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                fullDecks[type] = Array.isArray(data) ? data : [];
                return fullDecks[type];
            } catch (error) {
                console.error("Failed to fetch or parse data:", error);
                cardStack.innerHTML = `<div class="text-red-500 text-center p-4">Lỗi tải dữ liệu. Vui lòng kiểm tra kết nối mạng và thử lại.</div>`;
                return [];
            }
        }

        // --- UI and Card Logic ---
        function createCard(item) {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
                <div class="card-inner">
                    <div class="card-face card-face--front bg-white">
                        <span class="text-2xl md:text-3xl font-bold">${item.en}</span>
                    </div>
                    <div class="card-face card-face--back bg-blue-50">
                        <span class="text-xl md:text-2xl font-medium text-blue-800">${item.vi}</span>
                    </div>
                </div>
            `;
            return card;
        }

        function renderCards() {
            cardStack.innerHTML = '';
            const cardsToRender = currentData.slice(currentIndex, currentIndex + 3).reverse();
            
            cardsToRender.forEach((item, index) => {
                const cardElement = createCard(item);
                if (index < 2) {
                    cardElement.style.transform = `translateY(${(index + 1) * 10}px) translateZ(-${(index + 1) * 20}px)`;
                    cardElement.style.opacity = 1 - (index + 1) * 0.1;
                }
                cardStack.appendChild(cardElement);
            });
            
            if (currentIndex >= currentData.length && currentData.length > 0) {
                showCompletionScreen();
            } else {
                 activeCard = cardStack.lastElementChild;
                 if(activeCard) addDragListeners(activeCard);
            }
            updateProgress();
        }

        function updateProgress() {
            if (isReviewing) {
                progressInfo.textContent = `Đang ôn tập: ${currentIndex} / ${currentData.length} | Biết: ${reviewSessionStats.knownCount} | Chưa biết: ${reviewSessionStats.unknownCount}`;
            } else if (fullDecks[activeDeckType].length > 0) {
                const stats = deckStats[activeDeckType];
                progressInfo.textContent = `Đã học: ${stats.seenWords.size} / ${fullDecks[activeDeckType].length} | Biết: ${stats.knownCount} | Chưa biết: ${stats.unknownCount}`;
            } else {
                progressInfo.textContent = '';
            }
        }
        
        function showCompletionScreen() {
            let stats;
            const message = isReviewing ? "Bạn đã ôn tập xong!" : "Hoàn thành bộ thẻ!";
            if (isReviewing) {
                stats = reviewSessionStats;
            } else {
                stats = deckStats[activeDeckType];
            }
            
            cardStack.innerHTML = `
                <div class="bg-white rounded-2xl p-8 text-center shadow-lg w-full h-full flex flex-col justify-center items-center">
                    <h2 class="text-2xl font-bold text-green-600 mb-4">${message}</h2>
                    <p class="text-lg">Biết: <span class="font-bold text-green-500">${stats.knownCount}</span> | Chưa biết: <span class="font-bold text-red-500">${stats.unknownCount}</span></p>
                    ${!isReviewing ? `<button onclick="fullRestart()" class="mt-6 px-6 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600">Học lại từ đầu</button>` : ''}
                </div>
            `;
        }
        
        // FIX: New function to completely reset a deck's progress
        function fullRestart() {
            deckStats[activeDeckType] = { knownCount: 0, unknownCount: 0, seenWords: new Set() };
            reviewLists[activeDeckType] = [];
            loadDeck(activeDeckType);
        }

        function restartSession() {
            currentIndex = 0;
            if (isReviewing) {
                reviewSessionStats = { knownCount: 0, unknownCount: 0 };
            }
            renderCards();
        }

        async function loadDeck(type) {
            activeDeckType = type;
            isReviewing = false;
            mainTitle.textContent = "Flashcard Tiếng Anh";
            deckSelection.classList.remove('hidden');
            reviewControls.classList.add('hidden');

            loadingIndicator.style.display = 'flex';
            cardStack.innerHTML = ''; 
            cardStack.appendChild(loadingIndicator);
            
            const url = type === 'vocab' ? VOCAB_URL : SENTENCES_URL;
            const originalDeck = await fetchData(url, type);
            
            // FIX: Filter out already seen words
            const seen = deckStats[type].seenWords;
            currentData = originalDeck.filter(item => !seen.has(item.en));
            currentData.sort(() => Math.random() - 0.5); 

            restartSession();
            loadingIndicator.style.display = 'none';
            updateReviewButton();
        }

        // --- Review Logic ---
        function updateReviewButton() {
            const count = reviewLists[activeDeckType].length;
            if (count > 0) {
                btnReview.classList.remove('hidden');
                btnReview.disabled = false;
                btnReview.textContent = `Ôn tập (${count})`;
            } else {
                btnReview.classList.add('hidden');
                btnReview.disabled = true;
            }
        }

        function startReview() {
            const currentReviewList = reviewLists[activeDeckType];
            if (currentReviewList.length === 0) return;
            
            isReviewing = true;
            deckBeingReviewed = activeDeckType;
            mainTitle.textContent = "Chế độ ôn tập";
            deckSelection.classList.add('hidden');
            reviewControls.classList.remove('hidden');

            currentData = [...currentReviewList]; 
            currentData.sort(() => Math.random() - 0.5);
            restartSession();
        }

        function endReview() {
            loadDeck(deckBeingReviewed);
        }

        // --- Swipe/Drag Logic ---
        function swipe(direction) {
            if (!activeCard) return;

            const swipedItem = currentData[currentIndex];
            
            if (direction === 'right') {
                if (isReviewing) {
                    reviewSessionStats.knownCount++;
                    const reviewList = reviewLists[deckBeingReviewed];
                    const indexInUnknown = reviewList.findIndex(item => item.en === swipedItem.en);
                    if (indexInUnknown > -1) {
                        reviewList.splice(indexInUnknown, 1);
                    }
                } else {
                    deckStats[activeDeckType].knownCount++;
                }
            } else { // direction === 'left'
                if (isReviewing) {
                    reviewSessionStats.unknownCount++;
                } else {
                    deckStats[activeDeckType].unknownCount++;
                    const reviewList = reviewLists[activeDeckType];
                    if (!reviewList.some(item => item.en === swipedItem.en)) {
                        reviewList.push(swipedItem);
                    }
                }
            }
            
            // Add to seenWords only in normal learning mode
            if (!isReviewing) {
                deckStats[activeDeckType].seenWords.add(swipedItem.en);
                updateReviewButton();
            }
            
            const flyOutX = (direction === 'right' ? 1 : -1) * (cardStack.offsetWidth + 100);
            const rotation = (direction === 'right' ? 1 : -1) * 30;
            activeCard.style.transform = `translateX(${flyOutX}px) rotate(${rotation}deg)`;
            activeCard.style.opacity = '0';
            
            currentIndex++;
            
            setTimeout(() => {
                renderCards();
            }, 500);
        }
        
        function dragStart(e) {
            if (!activeCard) return;
            isDragging = true;
            startX = e.pageX ?? e.touches[0].pageX;
            startY = e.pageY ?? e.touches[0].pageY;
            currentX = 0;
            currentY = 0;
            activeCard.classList.add('dragging');
        }

        function dragMove(e) {
            if (!isDragging || !activeCard) return;
            e.preventDefault();
            currentX = (e.pageX ?? e.touches[0].pageX) - startX;
            currentY = (e.pageY ?? e.touches[0].pageY) - startY;

            const rotation = currentX / 20;
            
            activeCard.style.transform = `translateX(${currentX}px) rotate(${rotation}deg)`;
            
            if (currentX > 10) {
                knowIndicator.style.opacity = Math.abs(currentX) / 100;
                unknownIndicator.style.opacity = 0;
            } else if (currentX < -10) {
                unknownIndicator.style.opacity = Math.abs(currentX) / 100;
                knowIndicator.style.opacity = 0;
            } else {
                 knowIndicator.style.opacity = 0;
                 unknownIndicator.style.opacity = 0;
            }
        }

        function dragEnd() {
            if (!isDragging || !activeCard) return;
            isDragging = false;

            activeCard.classList.remove('dragging');
            knowIndicator.style.opacity = 0;
            unknownIndicator.style.opacity = 0;
            
            const tapThreshold = 15;
            const movedDistance = Math.sqrt(currentX*currentX + currentY*currentY);

            if (movedDistance < tapThreshold) {
                activeCard.classList.toggle('is-flipped');
                activeCard.style.transform = '';
                return;
            }

            const swipeThresholdX = cardStack.offsetWidth * 0.35;
            const swipeThresholdY = cardStack.offsetHeight * 0.25;

            if (Math.abs(currentX) > swipeThresholdX && Math.abs(currentX) > Math.abs(currentY)) {
                swipe(currentX > 0 ? 'right' : 'left');
            }
            else if (currentY > swipeThresholdY && Math.abs(currentY) > Math.abs(currentX)) {
                activeCard.classList.toggle('is-flipped');
                activeCard.style.transform = '';
            }
            else {
                activeCard.style.transform = '';
            }

            currentX = 0;
            currentY = 0;
        }

        function addDragListeners(element) {
            element.addEventListener('mousedown', dragStart);
            element.addEventListener('touchstart', dragStart, { passive: true });
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('touchmove', dragMove, { passive: false });
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);
        }

        // --- Event Listeners Setup ---
        btnVocab.addEventListener('click', () => {
            loadDeck('vocab');
            btnVocab.classList.replace('bg-gray-300', 'bg-blue-500');
            btnVocab.classList.replace('text-gray-700', 'text-white');
            btnSentences.classList.replace('bg-blue-500', 'bg-gray-300');
            btnSentences.classList.replace('text-white', 'text-gray-700');
        });

        btnSentences.addEventListener('click', () => {
            loadDeck('sentences');
            btnSentences.classList.replace('bg-gray-300', 'bg-blue-500');
            btnSentences.classList.replace('text-gray-700', 'text-white');
            btnVocab.classList.replace('bg-blue-500', 'bg-gray-300');
            btnVocab.classList.replace('text-white', 'text-gray-700');
        });

        btnReview.addEventListener('click', startReview);
        btnBack.addEventListener('click', endReview);

        btnUnknown.addEventListener('click', () => swipe('left'));
        btnKnown.addEventListener('click', () => swipe('right'));
        
        btnInfo.addEventListener('click', () => {
            if (activeCard) {
                activeCard.classList.toggle('is-flipped');
            }
        });

        // --- Initial Load ---
        window.addEventListener('load', () => {
            loadDeck('vocab');
        });
    </script>
</body>
</html>
